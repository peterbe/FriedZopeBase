# -*- coding: iso-8859-1 -*

"""FriedZopeBase Utils ZopeTestCase
"""
import os, re, sys
import stat
import StringIO
import gzip
from time import time
if __name__ == '__main__':
    execfile(os.path.join(sys.path[0], 'framework.py'))
    
from classes import TestBase

try:
    from slimmer import js_slimmer, css_slimmer
except ImportError:
    print >>sys.stderr, "slimmer not installed"
    js_slimmer = css_slimmer = None

from App.Common import rfc1123_date
from Products.FriedZopeBase.Zope import EXPIRY_INFINITY
from Products.FriedZopeBase.Zope import registerImage, registerCSSFile, registerJSFile
from Products.FriedZopeBase.Zope import GzippedFile, BetterImageFile
from Products.FriedZopeBase.Zope import registerJSFiles, registerCSSFiles

right_here = lambda x: os.path.join(os.path.dirname(__file__), x)

def _gzip2ascii(gzipped_content):
    compressedstream = StringIO.StringIO(gzipped_content)
    gzipper = gzip.GzipFile(fileobj=compressedstream)
    return gzipper.read()

def _get_autogenerated_dir():
    # XXX Perhaps use an environment variable here instead
    # that puts the files in /var/www/cache/myproject/
    return os.path.join(right_here('.'), '.autogenerated')

class TestZope(TestBase):
    
    def tearDown(self):
        autogenerated_dir = _get_autogenerated_dir()
        if os.path.isdir(autogenerated_dir):
            for filename in os.listdir(autogenerated_dir):
                os.remove(os.path.join(autogenerated_dir, filename))
            os.rmdir(autogenerated_dir)
        TestBase.tearDown(self)
          
    def test_basic_BetterImageFile(self):
        """ test the BetterImageFile class """
        class MyProduct:
            pass
        mtime = os.stat(right_here('image.jpg'))[stat.ST_MTIME]
        registerImage(MyProduct, right_here('image.jpg'), rel_path='tests')
        instance = MyProduct()
        
        img = getattr(instance, 'image.jpg', None)
        self.assertNotEqual(img, None)
        
        # expect also that it creates a file called 
        # image.<mttime of file>.jpg
        img_infinite = getattr(instance, 'image.%s.jpg' % mtime, None)
        self.assertNotEqual(img_infinite, None)
        
        # expect this to be a BetterImageFile instance
        self.assertEqual(img.__class__, BetterImageFile)
        self.assertTrue(isinstance(img, BetterImageFile))
        
        # rendering it should return a big binary content load
        self.assertEqual(len(str(img)), os.stat(right_here('image.jpg'))[stat.ST_SIZE])
        self.assertEqual(len(str(img_infinite)), os.stat(right_here('image.jpg'))[stat.ST_SIZE])
        
        # there should now be a dict set in the instance called misc_infinite_aliases
        # which links 'image.jpg' to 'image.<mttime of file>.jpg'
        self.assertTrue(bool(getattr(instance, 'misc_infinite_aliases')))
        aliases = instance.misc_infinite_aliases
        self.assertTrue(isinstance(aliases, dict))
        
        self.assertTrue('image.jpg' in aliases)
        
        self.assertEqual(aliases.get('image.jpg'), 'image.%s.jpg' % mtime)
        
        # if we render it with img.index_html() expect certain headers to be set
        REQUEST = self.app.REQUEST
        RESPONSE = REQUEST.RESPONSE
        bin_content = img.index_html(REQUEST, RESPONSE)
        
        self.assertEqual(RESPONSE.getHeader('last-modified'),
                         rfc1123_date(os.stat(right_here('image.jpg'))[stat.ST_MTIME]))
        self.assertEqual(RESPONSE.getHeader('cache-control'), 'public,max-age=3600') # default
        self.assertEqual(RESPONSE.getHeader('content-type'), 'image/jpeg')
        self.assertEqual(int(RESPONSE.getHeader('content-length')),
                         os.stat(right_here('image.jpg'))[stat.ST_SIZE])
                         
                         
        # if we render the infinitely cached one we can expect different headers
        bin_content = img_infinite.index_html(REQUEST, RESPONSE)
        
        self.assertEqual(RESPONSE.getHeader('last-modified'),
                         rfc1123_date(os.stat(right_here('image.jpg'))[stat.ST_MTIME]))
        self.assertEqual(RESPONSE.getHeader('cache-control'), 'public,max-age=%s' % EXPIRY_INFINITY) #
        self.assertEqual(RESPONSE.getHeader('content-type'), 'image/jpeg')
        self.assertEqual(int(RESPONSE.getHeader('content-length')),
                         os.stat(right_here('image.jpg'))[stat.ST_SIZE])
                         
        
    def test_set_expiry_header(self):
        """ if you register the image with @set_expiry_header=True, expect another header
        called 'Expires' 
        """
        class MyProduct:
            pass
        
        registerImage(MyProduct, 'image.jpg', rel_path='tests', set_expiry_header=True)
        instance = MyProduct()
        img = getattr(instance, 'image.jpg')
        
        REQUEST = self.app.REQUEST
        RESPONSE = REQUEST.RESPONSE
        bin_content = img.index_html(REQUEST, RESPONSE)
        
        self.assertEqual(RESPONSE.getHeader('last-modified'),
                         rfc1123_date(os.stat(right_here('image.jpg'))[stat.ST_MTIME]))
        self.assertEqual(RESPONSE.getHeader('cache-control'), 'public,max-age=3600') # default
        self.assertEqual(RESPONSE.getHeader('content-type'), 'image/jpeg')
        self.assertEqual(int(RESPONSE.getHeader('content-length')),
                         os.stat(right_here('image.jpg'))[stat.ST_SIZE])
        
        self.assertEqual(RESPONSE.getHeader('expires'),
                         rfc1123_date(time()+img.max_age))
                         
        # expect a expires header for the infinitely cached alias
        img_infinite_name = instance.misc_infinite_aliases['image.jpg']
        img_infinite = getattr(instance, img_infinite_name)
        bin_content = img_infinite.index_html(REQUEST, RESPONSE)
        self.assertEqual(RESPONSE.getHeader('expires'),
                         rfc1123_date(time()+EXPIRY_INFINITY))

                        
        
        
    def test_large_BetterImageFile(self):
        """ test the BetterImageFile() class but with larger images """
        class MyProduct:
            pass
        
        registerImage(MyProduct, 'large.jpg', rel_path='tests', set_expiry_header=True)
        instance = MyProduct()
        img = getattr(instance, 'large.jpg')
        
        REQUEST = self.app.REQUEST
        RESPONSE = REQUEST.RESPONSE
        bin_content = img.index_html(REQUEST, RESPONSE)
        
        # make sure it's an iterator we received
        self.assertTrue(isinstance(bin_content, open))
        
        _content = bin_content.read()
        self.assertEqual(len(_content), os.stat(right_here('large.jpg'))[stat.ST_SIZE])

        
    def test_registerCSSFile(self):
        class MyProduct:
            pass
        
        registerCSSFile(MyProduct, 'test.css', rel_path='tests', 
                        set_expiry_header=True,
                        slim_if_possible=False
                        )
        instance = MyProduct()
        static = getattr(instance, 'test.css')
        
        test_css_stat = os.stat(right_here('test.css'))
        
        # run through the same tests as above but with this
        mtime = test_css_stat[stat.ST_MTIME]
        static_infinite = getattr(instance, 'test.%s.css' % mtime, None)
        self.assertNotEqual(static_infinite, None)
        
        self.assertEqual(len(str(static)), test_css_stat[stat.ST_SIZE])
        self.assertEqual(len(str(static_infinite)), test_css_stat[stat.ST_SIZE])
        
        # if we render it with img.index_html() expect certain headers to be set
        REQUEST = self.app.REQUEST
        RESPONSE = REQUEST.RESPONSE
        bin_content = static.index_html(REQUEST, RESPONSE)
        
        self.assertEqual(RESPONSE.getHeader('last-modified'),
                         rfc1123_date(os.stat(right_here('test.css'))[stat.ST_MTIME]))
        self.assertEqual(RESPONSE.getHeader('cache-control'), 'public,max-age=3600') # default
        self.assertEqual(RESPONSE.getHeader('content-type'), 'text/css')
        self.assertEqual(int(RESPONSE.getHeader('content-length')),
                         os.stat(right_here('test.css'))[stat.ST_SIZE])
                         
                         
        # if we render the infinitely cached one we can expect different headers
        bin_content = static_infinite.index_html(REQUEST, RESPONSE)
        
        self.assertEqual(RESPONSE.getHeader('last-modified'),
                         rfc1123_date(os.stat(right_here('test.css'))[stat.ST_MTIME]))
        self.assertEqual(RESPONSE.getHeader('cache-control'), 'public,max-age=%s' % EXPIRY_INFINITY) #
        self.assertEqual(RESPONSE.getHeader('content-type'), 'text/css')
        self.assertEqual(int(RESPONSE.getHeader('content-length')),
                         os.stat(right_here('test.css'))[stat.ST_SIZE])
        

    def test_registerJSFile(self):
        class MyProduct:
            pass
        
        registerJSFile(MyProduct, 'test.js', rel_path='tests', 
                       set_expiry_header=True,
                       slim_if_possible=False)
        instance = MyProduct()
        static = getattr(instance, 'test.js')
        
        # run through the same tests as above but with this
        mtime = os.stat(right_here('test.js'))[stat.ST_MTIME]
        static_infinite = getattr(instance, 'test.%s.js' % mtime, None)
        self.assertNotEqual(static_infinite, None)
        
        self.assertEqual(len(str(static)), os.stat(right_here('test.js'))[stat.ST_SIZE])
        self.assertEqual(len(str(static_infinite)), os.stat(right_here('test.js'))[stat.ST_SIZE])
        
        # if we render it with img.index_html() expect certain headers to be set
        REQUEST = self.app.REQUEST
        RESPONSE = REQUEST.RESPONSE
        bin_content = static.index_html(REQUEST, RESPONSE)
        
        self.assertEqual(RESPONSE.getHeader('last-modified'),
                         rfc1123_date(os.stat(right_here('test.js'))[stat.ST_MTIME]))
        self.assertEqual(RESPONSE.getHeader('cache-control'), 'public,max-age=3600') # default
        self.assertEqual(RESPONSE.getHeader('content-type'), 'application/x-javascript')
        self.assertEqual(int(RESPONSE.getHeader('content-length')),
                         os.stat(right_here('test.js'))[stat.ST_SIZE])
                         
                         
        # if we render the infinitely cached one we can expect different headers
        bin_content = static_infinite.index_html(REQUEST, RESPONSE)
        
        self.assertEqual(RESPONSE.getHeader('last-modified'),
                         rfc1123_date(os.stat(right_here('test.js'))[stat.ST_MTIME]))
        self.assertEqual(RESPONSE.getHeader('cache-control'), 'public,max-age=%s' % EXPIRY_INFINITY) #
        self.assertEqual(RESPONSE.getHeader('content-type'), 'application/x-javascript')
        self.assertEqual(int(RESPONSE.getHeader('content-length')),
                         os.stat(right_here('test.js'))[stat.ST_SIZE])
        
                         
    def test_registering_with_slimming_basic(self):
        try:
            from slimmer import js_slimmer, css_slimmer
        except ImportError:
            # not possible to test this
            return
        
        class MyProduct:
            pass
        
        
        instance = MyProduct()
        
        registerJSFile(MyProduct, 'test.js', rel_path='tests', 
                    set_expiry_header=True,
                    slim_if_possible=True)
        
        static = getattr(instance, 'test.js')
        self.assertEqual(str(static), js_slimmer(open(right_here('test.js')).read()))
        
        # this will have created a file called 'test.js-slimmed.js' whose content
        # is the same as str(static)
        copy_test_js = os.path.join(_get_autogenerated_dir(), 'test.js-slimmed.js')
        self.assertTrue(os.path.isfile(copy_test_js))
        self.assertEqual(open(copy_test_js).read(), str(static))
        # and it that directory there should not be any other files
        for f in os.listdir(os.path.dirname(copy_test_js)):
            self.assertEqual(f, os.path.basename(copy_test_js))

        registerCSSFile(MyProduct, 'test.css', rel_path='tests', 
                        set_expiry_header=True,
                        slim_if_possible=True
                    )
        static = getattr(instance, 'test.css')
        self.assertEqual(str(static), css_slimmer(open(right_here('test.css')).read()))
        
        # this will have created a file called 'test.css-slimmed.css' whose content
        # is the same as str(static)
        copy_test_css = os.path.join(_get_autogenerated_dir(), 'test.css-slimmed.css')
        self.assertTrue(os.path.isfile(copy_test_css))
        self.assertEqual(open(copy_test_css).read(), str(static))
        # and it that directory there should not be any other files other
        # than the one we made before called test.js-slimmed.js
        for f in os.listdir(os.path.dirname(copy_test_css)):
            self.assertTrue(f == os.path.basename(copy_test_js) or \
                            f == os.path.basename(copy_test_css))
            
        
        # if you don it again it should just overwrite the old one
        registerCSSFile(MyProduct, 'test.css', rel_path='tests', 
                        set_expiry_header=True,
                        slim_if_possible=True,
                        
                    )
        
        static = getattr(instance, 'test.css')
        # there should still only be two files in the autogenerated directory
        self.assertEqual(len(os.listdir(_get_autogenerated_dir())), 2)


    def test_registering_with_slimming_and_gzip(self):
        try:
            from slimmer import js_slimmer, css_slimmer
        except ImportError:
            # not possible to test this
            return
        
        class MyProduct:
            pass
        
        
        instance = MyProduct()
        
        registerJSFile(MyProduct, 'test.js', rel_path='tests', 
                       set_expiry_header=True,
                       slim_if_possible=True,
                       gzip_if_possible=True)
        
        static = getattr(instance, 'test.js')
        # Note, using str(static) means it does not send the Accept-Encoding: gzip 
        # header.
        self.assertEqual(str(static),
                         js_slimmer(open(right_here('test.js')).read()))
        

        # this will have created a file called 'test.js-slimmed.js' whose content
        # is the same as str(static)
        copy_test_js = os.path.join(_get_autogenerated_dir(), 'test.js-slimmed.js')
        self.assertTrue(os.path.isfile(copy_test_js))
        self.assertEqual(open(copy_test_js).read(), str(static))
        # it would also have generated another copy called 
        # test.js-slimmed.js.gz
        copy_test_js_gz = os.path.join(_get_autogenerated_dir(), 'test.js-slimmed.js.gz')
        self.assertTrue(os.path.isfile(copy_test_js_gz))

        self.assertEqual(gzip.open(copy_test_js_gz).read(),
                         str(static))
        
        
        registerCSSFile(MyProduct, 'test.css', rel_path='tests', 
                        set_expiry_header=True,
                        slim_if_possible=True,
                        gzip_if_possible=True)
        static = getattr(instance, 'test.css')
        self.assertEqual(str(static), css_slimmer(open(right_here('test.css')).read()))
        
        # this will have created a file called 'test.css-slimmed.css' whose content
        # is the same as str(static)
        copy_test_css = os.path.join(_get_autogenerated_dir(), 'test.css-slimmed.css')
        self.assertTrue(os.path.isfile(copy_test_css))
        self.assertEqual(open(copy_test_css).read(), str(static))
        # it would also have generated another copy called 
        # test.css-slimmed.css.gz
        copy_test_css_gz = os.path.join(_get_autogenerated_dir(), 'test.css-slimmed.css.gz')
        self.assertTrue(os.path.isfile(copy_test_css_gz))

        self.assertEqual(gzip.open(copy_test_css_gz).read(),
                         str(static))
        
        # if you don it AGAIN it should just overwrite the old one
        registerCSSFile(MyProduct, 'test.css', rel_path='tests', 
                        set_expiry_header=True,
                        slim_if_possible=True,
                        gzip_if_possible=True)

        static = getattr(instance, 'test.css')
        self.assertEqual(str(static), 
                         css_slimmer(open(right_here('test.css')).read()))


    def test_registering_with_slimming_and_images_in_css(self):
        try:
            from slimmer import js_slimmer, css_slimmer
        except ImportError:
            # not possible to test this
            return
        
        class MyProduct:
            pass
        
        
        instance = MyProduct()
        
        # it will only fix images that have otherwise been registered
        registerImage(MyProduct, right_here('image.jpg'), rel_path='tests')

        registerCSSFile(MyProduct, 'containsimages.css', rel_path='tests', 
                        set_expiry_header=True,
                        slim_if_possible=True,
                        replace_images_with_aliases=True)
        static = getattr(instance, 'containsimages.css')
        
        # Not the same...
        self.assertNotEqual(str(static), 
                         css_slimmer(open(right_here('containsimages.css')
                                         ).read()))
        # unless you remove all '.\d+.'
        self.assertEqual(re.sub('\.\d{10,11}\.', '.', str(static)),
                         css_slimmer(open(right_here('containsimages.css')
                                         ).read()))
        
        # because we haven't registered large.jpg it won't be aliased
        self.assertTrue('large.jpg' in str(static))
        self.assertTrue('image.jpg' not in str(static))
        
        self.assertEqual(sorted(['containsimages.css-slimmed.css-aliased.css', 
                                 'containsimages.css-slimmed.css']),
                         sorted(os.listdir(_get_autogenerated_dir())))

        # if you don it again it should just overwrite the old one
        registerCSSFile(MyProduct, 'containsimages.css', rel_path='tests', 
                        set_expiry_header=True,
                        slim_if_possible=True,
                        replace_images_with_aliases=True
                    )
        
        self.assertEqual(sorted(['containsimages.css-slimmed.css-aliased.css', 
                                 'containsimages.css-slimmed.css']),
                         sorted(os.listdir(_get_autogenerated_dir())))


    def test_registering_with_slimming_and_gzip_and_images_in_css(self):
        try:
            from slimmer import js_slimmer, css_slimmer
        except ImportError:
            # not possible to test this
            return
        
        class MyProduct:
            pass
        
        
        instance = MyProduct()
        
        registerJSFile(MyProduct, 'test.js', rel_path='tests', 
                    set_expiry_header=True,
                    slim_if_possible=True)
        
        static = getattr(instance, 'test.js')
        self.assertEqual(str(static), js_slimmer(open(right_here('test.js')).read()))

        registerCSSFile(MyProduct, 'test.css', rel_path='tests', 
                        set_expiry_header=True,
                        slim_if_possible=True,
                        gzip_if_possible=True)
        static = getattr(instance, 'test.css')
        self.assertEqual(str(static), css_slimmer(open(right_here('test.css')).read()))
        
        # if you don it again it should just overwrite the old one
        registerCSSFile(MyProduct, 'test.css', rel_path='tests', 
                        set_expiry_header=True,
                        slim_if_possible=True,
                        gzip_if_possible=True)

        static = getattr(instance, 'test.css')
        self.assertEqual(str(static), css_slimmer(open(right_here('test.css')).read()))
        


    
                        
        
    def test_basic_GzippedImageFile(self):
        """ test registering a css file or a js file with gzip_if_possible=True """
        # first without also slimming
        class MyProduct:
            pass
        
        registerJSFile(MyProduct, 'test.js', rel_path='tests', 
                       set_expiry_header=True,
                       slim_if_possible=False,
                       gzip_if_possible=True)
        instance = MyProduct()
        static = getattr(instance, 'test.js')
        
        REQUEST = self.app.REQUEST
        RESPONSE = REQUEST.RESPONSE
        bin_content = static.index_html(REQUEST, RESPONSE)
        
        self.assertEqual(RESPONSE.getHeader('last-modified'),
                         rfc1123_date(os.stat(right_here('test.js'))[stat.ST_MTIME]))
        self.assertEqual(RESPONSE.getHeader('cache-control'), 'public,max-age=3600') # default
        self.assertEqual(RESPONSE.getHeader('content-type'), 'application/x-javascript')
        self.assertEqual(int(RESPONSE.getHeader('content-length')),
                         os.stat(right_here('test.js'))[stat.ST_SIZE])
                         
        # since our REQUEST does't have gzip in HTTP_ACCEPT_ENCODING 
        # we're not going to get the gzipped version
        self.assertEqual(len(bin_content), 
                         os.stat(right_here('test.js'))[stat.ST_SIZE])
        
        # now change HTTP_ACCEPT_ENCODING
        REQUEST.set('HTTP_ACCEPT_ENCODING','gzip')
        bin_content = static.index_html(REQUEST, RESPONSE)
        
        self.assertNotEqual(len(bin_content), 
                            os.stat(right_here('test.js'))[stat.ST_SIZE])
        
        data = _gzip2ascii(bin_content)
        self.assertEqual(data, 
                         open(right_here('test.js')).read())        
                
        
    def test_large_GzippedImageFile(self):
        """ test registering a css file or a js file with gzip_if_possible=True """
        class MyProduct:
            pass
        
        # first without also slimming
        registerJSFile(MyProduct, 'large.js', rel_path='tests', 
                       set_expiry_header=True,
                       slim_if_possible=False,
                       gzip_if_possible=True)
        instance = MyProduct()
        static = getattr(instance, 'large.js')
        
        REQUEST = self.app.REQUEST
        RESPONSE = REQUEST.RESPONSE
        bin_content = static.index_html(REQUEST, RESPONSE)
        
        self.assertEqual(RESPONSE.getHeader('last-modified'),
                         rfc1123_date(os.stat(right_here('large.js'))[stat.ST_MTIME]))
        self.assertEqual(RESPONSE.getHeader('cache-control'), 'public,max-age=3600') # default
        self.assertEqual(RESPONSE.getHeader('content-type'), 'application/x-javascript')
        self.assertEqual(int(RESPONSE.getHeader('content-length')),
                         os.stat(right_here('large.js'))[stat.ST_SIZE])
                         
        # since our REQUEST does't have gzip in HTTP_ACCEPT_ENCODING 
        # we're not going to get the gzipped version
        self.assertEqual(len(bin_content), 
                         os.stat(right_here('large.js'))[stat.ST_SIZE])
        
        # now change HTTP_ACCEPT_ENCODING
        REQUEST.set('HTTP_ACCEPT_ENCODING','gzip')
        bin_content = static.index_html(REQUEST, RESPONSE)
        self.assertTrue(isinstance(bin_content, open))
        _content = bin_content.read()
        
        self.assertNotEqual(len(_content), 
                            os.stat(right_here('large.js'))[stat.ST_SIZE])

        data = _gzip2ascii(_content)
        self.assertEqual(data, 
                         open(right_here('large.js')).read())
        
        
    def test_registerJSFiles(self):
        """ test the registerJSFiles() """
        class MyProduct:
            pass
        
        # test setting a bunch of files
        files = ['large.js','test.js']
        files.append(tuple(files))
        registerJSFiles(MyProduct, files, rel_path='tests',
                       set_expiry_header=True,
                       slim_if_possible=False,
                       gzip_if_possible=False)
                       
        instance = MyProduct()
        for filename in files:
            if isinstance(filename, tuple):
                filename = ','.join(filename)
            static = getattr(instance, filename)
            self.assertTrue(isinstance(static, BetterImageFile))
            
            
    def test_registerJSFiles__both_slimmed(self):
        """ test the registerJSFiles() with slim_if_possible=True """
        if js_slimmer is None:
            return 
        
        class MyProduct:
            pass
        
        # test setting a bunch of files
        files = ['large.js','test.js']
        files.append(tuple(files))
        registerJSFiles(MyProduct, files, rel_path='tests',
                       set_expiry_header=True,
                       slim_if_possible=True,
                       gzip_if_possible=False)
                       
        instance = MyProduct()
        for filename in files:
            if isinstance(filename, tuple):
                filename = ','.join(filename)
            static = getattr(instance, filename)
            self.assertTrue(isinstance(static, BetterImageFile))
            rendered = str(static)
            # expect this to be slimmed
            if len(filename.split(',')) > 1:
                content_parts = [open(right_here(x)).read() for x in filename.split(',')]
                expected_content = js_slimmer('\n'.join(content_parts))
            else:
                expected_content = js_slimmer(open(right_here(filename)).read())
            self.assertEqual(rendered.strip(), expected_content.strip())
            
            
    def test_registerJSFiles__one_slimmed(self):
        """ test the registerJSFiles() with slim_if_possible=True but one
        of the files shouldn't be slimmed because its filename indicates
        that it's already been slimmed/packed/minified. 

        In this test, the big challange is when two js files are combined 
        and one of them should be slimmed, the other one not slimmed.
        """
        
        class MyProduct:
            pass
        
        files = ['test.min.js','test.js']
        files.append(tuple(files))
        registerJSFiles(MyProduct, files, rel_path='tests',
                       set_expiry_header=True,
                       slim_if_possible=True,
                       gzip_if_possible=False)
                       
        instance = MyProduct()
        for filename in files:
            if isinstance(filename, tuple):
                filename = ','.join(filename)
            static = getattr(instance, filename)
            self.assertTrue(isinstance(static, BetterImageFile))
            rendered = str(static).strip()
            # expect this to be slimmed
            if len(filename.split(',')) > 1:
                
                content_parts = []
                for filename in filename.split(','):
                    content = open(right_here(filename)).read()
                    if filename.find('min') > -1 or js_slimmer is None:
                        content_parts.append(content)
                    else:
                        content_parts.append(js_slimmer(content))

                expected_content = '\n'.join(content_parts)
                expected_content = expected_content.strip()
                
            else:
                content = open(right_here(filename)).read()
                if filename.find('min') > -1 or js_slimmer is None:
                    expected_content = content
                else:
                    expected_content = js_slimmer(content)
                expected_content = expected_content.strip()
                
            self.assertEqual(rendered, expected_content)

            
            
    def test_registerJSFiles__both_slimmed_and_gzipped(self):
        """ test the registerJSFiles() with slim_if_possible=True """
        if js_slimmer is None:
            return
        
        class MyProduct:
            pass
        
        # test setting a bunch of files
        files = ['large.js','test.js']
        files.append(tuple(files))
        registerJSFiles(MyProduct, files, rel_path='tests',
                       set_expiry_header=True,
                       slim_if_possible=True,
                       gzip_if_possible=True)
                       
        instance = MyProduct()
        
        REQUEST = self.app.REQUEST
        RESPONSE = REQUEST.RESPONSE
        
        for filename in files:
            if isinstance(filename, tuple):
                filename = ','.join(filename)
            static = getattr(instance, filename)
            self.assertTrue(isinstance(static, BetterImageFile))
            
            # if you just call static.__str__() you're not calling it
            # with a REQUEST that accepts gzip encoding
            REQUEST.set('HTTP_ACCEPT_ENCODING','gzip')
            bin_rendered = static.index_html(REQUEST, RESPONSE)
            # expect this to be slimmed
            if len(filename.split(',')) > 1:
                content_parts = [open(right_here(x)).read() for x in filename.split(',')]
                expected_content = js_slimmer('\n'.join(content_parts))
            else:
                content = open(right_here(filename)).read()
                expected_content = js_slimmer(content)
                
            rendered = _gzip2ascii(bin_rendered)
            
            self.assertEqual(rendered.strip(), expected_content.strip())
            
            
    def test_registerJSFiles__one_slimmed_and_gzipped(self):
        """ test the registerJSFiles() with slim_if_possible=True but one
        of the files shouldn't be slimmed because its filename indicates
        that it's already been slimmed/packed/minified. 

        In this test, the big challange is when two js files are combined 
        and one of them should be slimmed, the other one not slimmed.
        """
        if js_slimmer is None:
            return
        
        class MyProduct:
            pass
        
        files = ['test.min.js','test.js']
        files.append(tuple(files))
        registerJSFiles(MyProduct, files, rel_path='tests',
                       set_expiry_header=True,
                       slim_if_possible=True,
                       gzip_if_possible=True)
                       
        REQUEST = self.app.REQUEST
        RESPONSE = REQUEST.RESPONSE
                       
        instance = MyProduct()
        for filename in files:
            if isinstance(filename, tuple):
                filename = ','.join(filename)
            static = getattr(instance, filename)
            self.assertTrue(isinstance(static, BetterImageFile))
            
            # if you just call static.__str__() you're not calling it
            # with a REQUEST that accepts gzip encoding
            REQUEST.set('HTTP_ACCEPT_ENCODING','gzip')
            bin_rendered = static.index_html(REQUEST, RESPONSE)
            
            # expect this to be slimmed
            if len(filename.split(',')) > 1:
                
                content_parts = []
                for filename in filename.split(','):
                    content = open(right_here(filename)).read()
                    if filename.find('min') > -1:
                        content_parts.append(content)
                    else:
                        if js_slimmer is None:
                            content_parts.append(content)
                        else:
                            content_parts.append(js_slimmer(content))

                expected_content = '\n'.join(content_parts)
                expected_content = expected_content.strip()
                
            else:
                if filename.find('min') > -1:
                    expected_content = open(right_here(filename)).read()
                else:
                    content = open(right_here(filename)).read()
                    if js_slimmer is None:
                        expected_content = content
                    else:
                        expected_content = js_slimmer(content)
                expected_content = expected_content.strip()
                
            
            rendered = _gzip2ascii(bin_rendered)
            
            self.assertEqual(rendered.strip(), expected_content)
            

            
            
            
    # CSSFiles
    
    def test_registerCSSFiles_basic(self):
        """ test the registerCSSFiles() """
        
        class MyProduct:
            pass

        # test setting a bunch of files
        files = ['large.css','test.css']
        files.append(tuple(files))
        registerCSSFiles(MyProduct, files, rel_path='tests',
                       set_expiry_header=True,
                       slim_if_possible=False,
                       gzip_if_possible=False)
                       
        instance = MyProduct()
        for filename in files:
            if isinstance(filename, tuple):
                filename = ','.join(filename)
            static = getattr(instance, filename)
            self.assertTrue(isinstance(static, BetterImageFile))
            
            
    def test_registerCSSFiles__both_slimmed(self):
        """ test the registerCSSFiles() with slim_if_possible=True """
        if css_slimmer is None:
            return 
        try:
            
            class MyProduct:
                pass
            
            # test setting a bunch of files
            files = ['large.css','test.css']
            files.append(tuple(files))
            registerCSSFiles(MyProduct, files, rel_path='tests',
                           set_expiry_header=True,
                           slim_if_possible=True,
                           gzip_if_possible=False)
                           
            instance = MyProduct()
            for filename in files:
                if isinstance(filename, tuple):
                    filename = ','.join(filename)
                static = getattr(instance, filename)
                self.assertTrue(isinstance(static, BetterImageFile))
                rendered = str(static)
                # expect this to be slimmed
                if len(filename.split(',')) > 1:
                    content_parts = [open(right_here(x)).read() for x in filename.split(',')]
                    expected_content = '\n'.join([css_slimmer(x) for x in content_parts])
                else:
                    expected_content = css_slimmer(open(right_here(filename)).read())
                self.assertEqual(rendered.strip(), expected_content.strip())
        except ImportError:
            pass
            
            
    def test_registerCSSFiles__one_slimmed(self):
        """ test the registerCSSFiles() with slim_if_possible=True but one
        of the files shouldn't be slimmed because its filename indicates
        that it's already been slimmed/packed/minified. 

        In this test, the big challange is when two js files are combined 
        and one of them should be slimmed, the other one not slimmed.
        """
        if css_slimmer is None:
            return 
        
        class MyProduct:
            pass
        
        files = ['test-min.css','test.css']
        files.append(tuple(files))
        registerCSSFiles(MyProduct, files, rel_path='tests',
                       set_expiry_header=True,
                       slim_if_possible=True,
                       gzip_if_possible=False)
                       
        instance = MyProduct()
        for filename in files:
            if isinstance(filename, tuple):
                filename = ','.join(filename)
            static = getattr(instance, filename)
            self.assertTrue(isinstance(static, BetterImageFile))
            rendered = str(static).strip()
            # expect this to be slimmed partially
            if len(filename.split(',')) > 1:
                
                content_parts = []
                for filename in filename.split(','):
                    content = open(right_here(filename)).read()
                    if filename.find('min') > -1:
                        content_parts.append(content)
                    else:
                        content_parts.append(css_slimmer(content))

                expected_content = '\n'.join(content_parts)
                expected_content = expected_content.strip()
            else:
                if filename.find('min') > -1:
                    expected_content = open(right_here(filename)).read()
                else:
                    expected_content = css_slimmer(open(right_here(filename)).read())
                expected_content = expected_content.strip()
                
            self.assertEqual(rendered.strip(), expected_content)

            
            
    def test_registerCSSFiles__both_slimmed_and_gzipped(self):
        """ test the registerCSSFiles() with slim_if_possible=True """
        if css_slimmer is None:
            return
        
        class MyProduct:
            pass
        
        # test setting a bunch of files
        files = ['large.css','test.css']
        files.append(tuple(files))
        registerCSSFiles(MyProduct, files, rel_path='tests',
                       set_expiry_header=True,
                       slim_if_possible=True,
                       gzip_if_possible=True)
                       
        instance = MyProduct()
        
        REQUEST = self.app.REQUEST
        RESPONSE = REQUEST.RESPONSE
        
        for filename in files:
            if isinstance(filename, tuple):
                filename = ','.join(filename)
            static = getattr(instance, filename)
            self.assertTrue(isinstance(static, BetterImageFile))
            
            # if you just call static.__str__() you're not calling it
            # with a REQUEST that accepts gzip encoding
            REQUEST.set('HTTP_ACCEPT_ENCODING','gzip')
            bin_rendered = static.index_html(REQUEST, RESPONSE)
            rendered = _gzip2ascii(bin_rendered).strip()
            
            # expect this to be slimmed
            if len(filename.split(',')) > 1:
                content_parts = [open(right_here(x)).read() for x in filename.split(',')]
                
                if css_slimmer is None:
                    expected_content = '\n'.join(content_parts)
                else:
                    expected_content = '\n'.join([css_slimmer(x) for x in content_parts])
            else:
                content = open(right_here(filename)).read()
                if css_slimmer is None:
                    expected_content = content
                else:
                    expected_content = css_slimmer(content)
                
            self.assertEqual(rendered.strip(), expected_content.strip())
            
            
    def test_registerCSSFiles__one_slimmed_and_gzipped(self):
        """ test the registerCSSFiles() with slim_if_possible=True but one
        of the files shouldn't be slimmed because its filename indicates
        that it's already been slimmed/packed/minified. 

        In this test, the big challange is when two js files are combined 
        and one of them should be slimmed, the other one not slimmed.
        """
        if css_slimmer is None:
            return
        
        class MyProduct:
            pass
        
        files = ['test-min.css','test.css']
        files.append(tuple(files))
        registerCSSFiles(MyProduct, files, rel_path='tests',
                       set_expiry_header=True,
                       slim_if_possible=True,
                       gzip_if_possible=True)
                       
        REQUEST = self.app.REQUEST
        RESPONSE = REQUEST.RESPONSE
                       
        instance = MyProduct()
        for filename in files:
            if isinstance(filename, tuple):
                filename = ','.join(filename)
            static = getattr(instance, filename)
            self.assertTrue(isinstance(static, BetterImageFile))
            
            # if you just call static.__str__() you're not calling it
            # with a REQUEST that accepts gzip encoding
            REQUEST.set('HTTP_ACCEPT_ENCODING','gzip')
            bin_rendered = static.index_html(REQUEST, RESPONSE)
            
            # expect this to be slimmed
            if len(filename.split(',')) > 1:
                
                content_parts = []
                for filename in filename.split(','):
                    content = open(right_here(filename)).read()
                    if filename.find('min') > -1:
                        content_parts.append(content)
                    else:
                        content_parts.append(css_slimmer(content))

                expected_content = '\n'.join(content_parts)
                expected_content = expected_content.strip()
                
            else:
                if filename.find('min') > -1:
                    expected_content = open(right_here(filename)).read()
                else:
                    expected_content = css_slimmer(open(right_here(filename)).read())
                expected_content = expected_content.strip()
                
            rendered = _gzip2ascii(bin_rendered)
            
            self.assertEqual(rendered.strip(), expected_content)
            
    
                
        
        
        

def test_suite():
    from unittest import TestSuite, makeSuite
    suite = TestSuite()
    suite.addTest(makeSuite(TestZope))
    return suite

if __name__ == '__main__':
    framework()


    
